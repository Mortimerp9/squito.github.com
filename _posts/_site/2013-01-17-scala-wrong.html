<p>I&#8217;ve been a Scala developer for just over half a year now. Scala is amazing; coming frmo a background in Java, it solves so many of the issues that aggravated me for years. But, because its still compiled to the JVM, I didn&#8217;t need to start completely from scratch; I can still draw on all the existing Java libraries, plus all the tools I&#8217;m used to using for debugging and diagnosing my Java programs. I&#8217;d have a hard time going back to programming in Java after this.</p>

<p>Despite my love of Scala, though, there are a few things that drive me bonkers. Maybe some Scala guru will see this post and take into consideration for future versions of the language &#8211; but almost certainly not. If I&#8217;m lucky, than this post might be read by someone else that is new to Scala, that is going through similar frustrations &#8211; at least this way they&#8217;ll know they are not alone. But, really, this post is just my chance to vent.</p>

<ol>
<li>
<p>Collections in Predef. Functional languages are really big on immutable data structures, and Scala is no exception. I had often wanted a way to force immutability in Java. Scala made a big improvement on this, by creating immutable and mutable versions of most collections, plus a common interface covering both. (I&#8217;m not a huge fan of the fact that the names are only differentiated by packages, but I can live with that.)</p>

<p>But, they made a horrible mistake when they included the <em>immutable</em> versions, instead of the <em>common interfaces</em> in Predef. I can only imagine that they did this because they wanted to bias everyone to use immutable collections by default, as all &#8220;good&#8221; functional programmers should. This means that when you write a method <code>def doXYZ(data:Map[String,Int]) : Boolean</code>, you have just defined a method that can <em>only</em> accept immutable maps. That might even by work fine for you when you write the method. But later on, another developer will come along and try to use that method with a mutable Map, and it won&#8217;t compile.</p>

<p>From now on, I always <code>import collection._</code>. That way, I get the generic interfaces by default in my API, and I explicitly request the mutable or immutable version of the collection if I want to, eg. <code>val m = mutable.Map[String,Int]()</code></p>
</li>

<li>
<p>DSL run amok. One of my biggest complaints about Java was the lack of operator overloading. Just look at the BigNumber api, you quickly see what a pain it is. Scala fixes this problem &#8211; code is so much cleaner by adding <code>apply</code>, <code>+=</code>, <code>++</code>, etc. Such a huge improvement. Unfortunately, Scala developers have gotten a little carried away. Libraries are full of so much crazy, <em>undocumented</em> operator overloading, it ends up making code inscrutable to anyone that isn&#8217;t an export in the library. I guess I&#8217;m not actually complaining about Scala itself here &#8211; it&#8217;s great that it lets you do this &#8211; I&#8217;m complaining about how much people abuse the ability to create custom DSL. Most often, my goal is invest as little time as possible in a tool to get what I need out of it &#8211; as a good Computer Scientist, I try to find the highest layer of abstraction that is still sufficient. Lots of DSL just makes that harder.</p>
</li>

<li>
<p>Slow compile times. Yes, I know, the Scala compiler is much more complicated than the Java compiler, that it has to work so much harder, etc. etc. It still annoys me. Even with large Java projects, I felt like the compiler (especially continuous compilation within Eclipse) was so fast that the compiler was never a burden. Compiling Scala code regularly grinds my laptop to a halt. The sad truth is, this leads to all sorts of bad development practices on my part, like not bothering to run unit tests because I don&#8217;t want to wait for the compiler. OK, maybe its unfair to say &#8220;Scala got it wrong&#8221; on this one, I just switch I could speed up compilation, eg. by turning off some of the features.</p>
</li>

<li>
<p>SBT. Simple Build Tool. I hope that choice of name was ironic. I used to use Ant as a Java developer; I won&#8217;t claim it was simple, or amazing, but at least it was well documented. But sbt project definitions are just Scala code! Sounds easy enough &#8211; as a Scala developer, I won&#8217;t have any trouble understanding, right? Nope, I&#8217;m just stuck in DSL hell. Yes, I know it is scala code, but even just getting past the crazy syntax, let alone tracking down the method definitions, is more than I want to deal with for setting up a simple build.</p>
</li>
</ol>

<p>OK, I&#8217;m done with my rant. Now I should write some more constructive posts about why I like scala, and how I&#8217;ve learned to use it. Am I alone in thinking these are problems with Scala? Does anybody have any solutions to these problems? I&#8217;d love to hear your feedback.</p>