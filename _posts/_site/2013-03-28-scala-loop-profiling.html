<p>I&#8217;ve started putting more effort into <a href='https://github.com/squito/sblaj/blob/master/ml/src/main/scala/org/sblaj/ml/lda/OnlineVBLDA.scala'>implementing machine learning algorithms in Scala</a>, and right away I started wondering about the performance of various ways of looping. I explored this a bit before I switched to Scala from Java, and I remember deciding that I could get comparable performance as long as I was careful to use primitive arrays.</p>

<p>But now that I&#8217;ve got a bit more experience using Scala, looping over arrays with a while loop looks horribly ugly. Not to mention, its extremely bug-prone &#8211; I often forget to increment the index. (Why doesn&#8217;t Scala have a proper for loop?)</p>

<p>So I wanted to compare the direct while loop to two alternatives:</p>

<ol>
<li><em>Tail Recursion</em>. Scala claims this gets compiled down to an iterative loop, so lets see if its true</li>

<li><em>Foreach over a Range</em>. This is probably the cleanest approach, but I thought the inline lambda functions would get compiled to calling a method on a class, which would have a lot of overhead.</li>
</ol>

<p>All of these experiments are with Scala 2.9.1-1, on a MacbookPro 2.4 GHz Intel Core i7, 8 GB 1333 MHz DDR3.</p>

<h2 id='my_experiments'>My Experiments</h2>

<p>The first thing I wanted to profile was a very simple loop over a giant array. I made a couple of modifications along the way, which I&#8217;ll discuss below, but here&#8217;s code I ended up with at the end. (I added the <code>array.foreach</code> towards the end of my experiments, so not all my results include it.)</p>

<pre><code>package org.sblaj.ml

import annotation.tailrec

object IterationTiming {
 def timeIterations(n: Int) {
   val arr = new Array[Int](n)
   var idx = 0
   val itrStart = System.currentTimeMillis()
   while (idx &lt; n) {
     arr(idx) = idx + 1
     idx += 1
   }
   val itrEnd = System.currentTimeMillis()
   println(&quot;itr took &quot; + (itrEnd - itrStart) + &quot;ms&quot;)

   @tailrec
   def tailRecItr(arr: Array[Int], idx: Int) {
     if (idx &gt;= n)
       return  //tailrec annotation not happy if recursive call is inside a condition, so have to use a return
     arr(idx) = idx + 2
     tailRecItr(arr, idx + 1)
   }
   val tailRecStart = System.currentTimeMillis()
   tailRecItr(arr, 0)
   val tailRecEnd = System.currentTimeMillis()
   println(&quot;tail rec took &quot; + (tailRecEnd - tailRecStart) + &quot;ms&quot;)

   val forStart = System.currentTimeMillis()
   (0 until n).foreach{idx =&gt; arr(idx) = idx + 3}
   val forEnd = System.currentTimeMillis()
   println(&quot;foreach took &quot; + (forEnd - forStart) + &quot;ms&quot;)


   idx = 0
   val itrStart2 = System.currentTimeMillis()
   while (idx &lt; n) {
     arr(idx) = idx + 1
     idx += 1
   }
   val itrEnd2 = System.currentTimeMillis()
   println(&quot;itr took &quot; + (itrEnd2 - itrStart2) + &quot;ms&quot;)

   //Try doing a foreach over anything other than a range.  Even just using an array w/ all the values
   // in it is *much* slower
   val range = (0 until n)
   val idxArray = range.toArray
   val arrayForStart = System.currentTimeMillis()
   idxArray.foreach{idx =&gt; arr(idx) = idx - 1}
   val arrayForEnd = System.currentTimeMillis()
   println(&quot;array foreach took &quot; + (arrayForEnd - arrayForStart) + &quot;ms&quot;)
 }

  def main(args: Array[String]) {
    timeIterations(args(0).toInt)
  }
}</code></pre>

<p>First, I tried just pasting the relevant code into the scala REPL, first setting <code>n = 1e6</code>. Here&#8217;s what I saw printed out:</p>

<pre><code>itr took 36ms
tail rec took 7ms
foreach took 573ms
itr took 46ms</code></pre>

<p>As I has suspected, the foreach loop took much longer. But I couldn&#8217;t understand why the tail-recursive version would be <em>faster</em>. I tried doing a similar experiment from within the sbt console, instead of the scala REPL, and got very similar results. Then I suspected the REPL might be doing something funny, so I put the code into a file and compiled it with sbt.</p>

<p>When run this way, the times were <strong>totally different</strong>. The experiments of pasting code in the REPL were totally misleading. After compiling the code, calling it from the REPL or a standalone java were pretty similar. Now the times were massively faster, but the relative comparison was different:</p>

<pre><code>scala&gt; org.sblaj.ml.IterationTiming.timeIterations(1e6.toInt)
itr took 4ms
tail rec took 3ms
foreach took 11ms
itr took 0ms

scala&gt; org.sblaj.ml.IterationTiming.timeIterations(1e7.toInt)
itr took 34ms
tail rec took 6ms
foreach took 11ms
itr took 6ms

scala&gt; org.sblaj.ml.IterationTiming.timeIterations(1e8.toInt)
itr took 79ms
tail rec took 73ms
foreach took 100ms
itr took 71ms</code></pre>

<p>One standalone run with <code>n = 5e8</code>, the warmed up iterative version was somewhat faster:</p>

<pre><code>bash-3.2$ scala -J-Xmx4G -cp ml/target/scala-2.9.1/classes/ org.sblaj.ml.IterationTiming 500000000
itr took 3049ms
tail rec took 1171ms
foreach took 515ms
itr took 399ms</code></pre>

<p>The iterative version was faster, but not by very much. I was puzzled.</p>

<h2 id='jitjavap_and_scalac'>JIT,javap, and scalac</h2>

<p>I thought that maybe the only reason the foreach was able to keep is because the hotspot compiler was able to eliminate its overhead and inline that code very quickly. Indeed, turning off the hotspot compiler <code>-Xint</code> did change the runtime, though not quite as expected:</p>

<pre><code>bash-3.2$ scala -J-Xint -J-Xmx1G -cp ml/target/scala-2.9.1/classes/ org.sblaj.ml.IterationTiming 100000000
itr took 1380ms
tail rec took 1499ms
foreach took 2407ms
itr took 1390ms</code></pre>

<p>I tried turning on extra info on what the hotspot compiler was doing with <code>-XX:+PrintCompilation</code>, and I was shocked to see it wasn&#8217;t doing anything special w/ the foreach! After looking with <code>javap</code>, I found out that the lambda is <em>already compiled away</em>. The foreach wasn&#8217;t another function call! This was a real shock. But, i also had my doubts, because according to javap, my tail-recursive function was still creating a function call. If that was really the case, there is no way it would have comparable performance.</p>

<pre><code>bash-3.2$ javap -classpath ml/target/scala-2.9.1/classes -c org.sblaj.ml.IterationTiming$
...
   91:  invokespecial   #55; //Method tailRecItr$1:([III)V
...</code></pre>

<p>I&#8217;m no expert on javap, but that sure looks like a method call. And the method its calling doesn&#8217;t seem to exist.</p>

<p>After some more digging, I found the answer for <code>foreach</code>: scalac already <a href='https://github.com/scala/scala/commit/4cfc633fc6'>optimizes foreach over Ranges</a>. So, all of that worrying for nothing; <code>foreach</code> was a bit slower, but not massively so. Its probably good enough in a lot of cases.</p>

<p>Just to be really sure I wasn&#8217;t crazy, I tried another foreach, not on a range (the last <code>array.foreach</code> in my code). This confirmed my expectations &#8211; it was much slower.</p>

<pre><code>bash-3.2$ scala -J-Xmx1G -cp ml/target/scala-2.9.1/classes/ org.sblaj.ml.IterationTiming 100000000
itr took 77ms
tail rec took 77ms
foreach took 106ms
itr took 57ms
array foreach took 430ms</code></pre>

<p>And without the JIT, it was devastatingly slow:</p>

<pre><code>bash-3.2$ scala -J-Xint -cp ml/target/scala-2.9.1/classes/ org.sblaj.ml.IterationTiming 1000000
itr took 14ms
tail rec took 15ms
foreach took 26ms
itr took 14ms
array foreach took 750ms</code></pre>

<p>If you&#8217;re interested in reading more on this topic, you can also check out these posts from other blogs, discussing other aspects of loop optimizations in scala:</p>

<ul>
<li><a href='http://ochafik.com/blog/?p=806'>Scalaxy/Loops: Optimized foreach loops for Scala 2.10.0 have landed</a></li>

<li><a href='http://dynamicsofprogramming.blogspot.co.uk/2013/01/loop-performance-and-local-variables-in.html'>Loop Performance and Local Variables in Scala</a></li>
</ul>

<h1 id='summary'>Summary</h1>

<ul>
<li>Never use the REPL for timing experiments! Its extremely misleading, not representative of the way you&#8217;ll really use your code. Its ok to invoke code from within the REPL when timing, but be sure the code is defined in a file that is compiled normally.</li>

<li><code>Range.foreach</code> is optimized. Yay! You can still get a bit faster w/ while loops, but the difference is not monumental. (Don&#8217;t be fooled into thinking this means <em>all</em> foreachs are fast &#8211; they&#8217;re not.)</li>

<li>The bytecode of tail-recursive calls is still mysterious &#8230; maybe more on that in the future.</li>
</ul>